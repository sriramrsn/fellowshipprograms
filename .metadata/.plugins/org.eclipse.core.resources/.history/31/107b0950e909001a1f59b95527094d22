package com.bridgelabz.fellowshipprograms.utility;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;
import java.util.regex.Matcher;

public class Utility {
	public static Scanner sc= new Scanner(System.in);
	
	/**
	 * purpose-These function reads the integer from the command line
	 * @return integer value
	 */
	public static int readInt()
	{
		return sc.nextInt();
	}

/*------------------------------Basic_cores-----------------------------------------------*/

	/**
	 * purpose-Count the number of heads and tails by providing the number of times coin tossed on the basis.
	 * @param n-number of times coin tossed.
	 * @return -array of integer.
	 */
	public static int[] flipCoin(int n)
	{
		int[] count = new int[2];
		for(int i=0;i<n;i++)
		{
			double d=Math.random();
			if(d<0.5)
			{
				count[0]++;
			}
			else
			{
				count[1]++;
			}
		}
		return count;
	}
	

//-----------------------------------------------------------------------------------

	/**
	 * purpose-To check weather the year is leap year or not by providing year as a input.
	 * @param year.
	 * @return-boolean if it return true then it is leap year otherwise not-leap year.
	 */
	public static boolean leapYear(int n)
	{
		if(n%4==0 || n%100!=0 && n%400==0)
		{
		return true;		
		}else 
		return false;
	}


//-----------------------------------------------------------------------------------
	
	/**
	 * purpose- prints a table of the powers of 2 that are less than or equal to 2^N.
	 * @param n is the power to the 2.
	 */
	public static void power2(int n)
	{
		//it will check the input is greater than or equals to zero and it is less than 31.
		if(n>=0 && n <31)
		{
			double temp= Math.pow(2, n);
		System.out.println("power "+temp);
		for(int i=1;i<=n;i++)
		{
			double temp1 = 2*i;
			if(temp1>temp)
			{
				System.out.println(""+temp1);
				break;
			}
			else 
			{ 
				System.out.println(""+temp1);
				continue;
			}
		}
		}	
	}
	

//-----------------------------------------------------------------------------------

	
	/**
	 * purpose-These method calculate the Nth harmonic number by providing the 'n' value at that range will calculated .
	 * @param n-it is integer value which we want calculate the harmonic of at that range.
	 * @return- sum - which is the harmonic number of 'n'.
	 */
	public static double harmonic(int n)
	{
		double temp,sum=0;
		for(int i=1;i<=n;i++)
		{
			temp=1/i;
			sum=sum+temp;
		}
		return sum;
	}


//-----------------------------------------------------------------------------------
	
	/**
	 * purpose-These method checks the input provided i.
	 * @param n-decimal number.
	 * @return -prime factors
	 */
	public static int primeFactor(int n)
	{
		int i;
		for( i=2;i*i<=n;i++)
		{
			while(n>0)
			{
				if(n%i==0)
				{	
					n=n/i;	
				}
			}	
		}

		return i;
	}


/*----------------------------------functional-----------------------------------------*/

	
	/**
	 * purpose-2d array
	 * @param i-rows
	 * @param j-columns
	 */
	public static void array2D(int i,int j)
	{
		int [][] a= new int[i][j];
		System.out.println("enter a array elements:");
		for(int r=0;r<i;r++)
		{
			for(int c=0;c<j;c++)
			{
				a[r][c]=sc.nextInt();
			}
		}
		for(int r=0;r<i;r++)
		{
			for(int c=0;c<j;c++)
			{
				System.out.print("\t" +a[r][c]);			
				}
			System.out.println();
		}	
	}
	
	

//-----------------------------------------------------------------------------------

	/**
	 * purpose-calculate euclidean distance from the point (x, y) to the origin (0, 0). 
	 * @param a-distance from x-coordinate.
	 * @param b-distance from y-coordinate.
	 * @return-distance
	 */
	public static double euclideDistance(double a,double b)
	{
		double temp=a*a+b*b;
		double d= Math.sqrt(temp);
		return d;
	}


//-----------------------------------------------------------------------------------

	/**
	 * purpose- calculate effective temperature.
	 * @param t-temperature.
	 * @param v-wind speed.
	 * @return
	 */
	public static double windChill(double t,double v)
	{
			double temp1 = 0.6215*t;
			double temp2 = 0.4275*t;
			double temp3 = temp2+35.75;
			double temp4 = Math.pow(v, 0.16);
			double w= 35.74+temp1+temp3*temp4;
			return w;	
	}
	

 /*----------------------------Algoritham-----------------------------------------------*/
	
	
	/**
	 * purpose
	 * @param initial
	 * @param remaining
	 */
	public static void permutatioRecursive(String initial,String remaining)
	{
		if(remaining.length()==0)
		{
			System.out.println(initial);
		}
		else
		{
			for(int i=0;i<remaining.length();i++)
			{
				String str1= initial+remaining.charAt(i);
				String str2= remaining.substring(0, i)+remaining.substring(i+1);
				permutatioRecursive(str1,str2);
			}
			
		}
	}
	

//-----------------------------------------------------------------------------------

	
	/**
	 * purpose 
	 * @param filename
	 * @param data
	 * @return
	 */
	public static String[] createFile(String filename,String data)
	{
		File myfile = new File(filename);
		String words[]=null;
		try {
			
				boolean createFile = myfile.createNewFile();
				if(createFile)
				{
					System.out.println("New File Successfully created");
				}else {
				
					
					FileWriter fw = new FileWriter("file.txt");
					fw.write(data);
					
					fw.close();
					
		
					FileReader fr = new FileReader(filename);
				
					BufferedReader br =  new BufferedReader(fr);
					
				
					String s;
				
				
					while((s=br.readLine())!=null)
					{
						words=s.split(",");
					}
					br.close();
				}
		}catch (Exception e)
		{
		
		}
		return words;
	}

//-------------------------------------------------------------------------------------
	
	/**
	 * @param a
	 */
	public static void printStringArray(String a[])
	{
		for(int i=0;i<a.length;i++)
		{
			System.out.println(a[i]);
		}
	}

	
//-------------------------------------------------------------------------------------
	/**
	 * @param <T>
	 * @param arr
	 * @return
	 */
	public static <T extends Comparable<T>> T[] bubbleSortGenerics(T[] arr)
	 {
		 int i,j;
		T temp;	
			for(i=0;i<arr.length-1;i++)
			{
				for(j=i+1;j<arr.length;j++)
				{
					if(arr[i].compareTo(arr[j])>=0)
					{
						temp=arr[i];
						arr[i]=arr[j];
						arr[j]=temp;
					}
				}
			}
		 return arr;
	 }

	
//-------------------------------------------------------------------------------------

	/**
	 * @param <T>
	 * @param arr
	 * @param low
	 * @param high
	 * @param key
	 * @return
	 */
	public static <T extends Comparable<T>> int binarySearchGenerics(T arr[], int low, int high, T key) 
	 { 
	     if (high >= low) { 
	         
	     	int mid = low + (high - low) / 2; 
	        
	     	if (arr[mid].compareTo(key)==0) 
	             return mid; 
	         
	     	if (arr[mid].compareTo(key)>0) 
	             return binarySearchGenerics(arr, low, mid - 1, key); 
	         
	     	return binarySearchGenerics(arr, mid + 1, high, key); 
	     } 

	     return -1; 
	 } 
	/**
	 * purpose-insertion sort.
	 * @param a-array of elements.
	 * @return-sorted array.
	 */
	public static int[] insertionSortInteger(int[] a)
	{
		int temp;
		for(int i=1;i<a.length;i++)
		{
			temp=a[i];
			int j= i-1;
			while(j>=0 && a[j]>temp)
			{
				a[j+1]=a[j];
				j=j-1;
			}
			a[j+1]=temp;		
		}
		
		return a;
	}

	/**
	 * purpose-insertion sort of string
	 * @param a
	 * @return
	 */
	public static String[] insertionSortString(String[] a)
	{
		int i,j;
		String temp="";
		for(i=0;i<a.length;i++)
		{
			for(j=i+1;j<a.length;j++)
			{
				if(a[i].compareToIgnoreCase(a[j])>0);
				{
					temp=a[i];
					a[i]=a[j];
					a[j]=temp;
				}
			}
		}
		return a;
	}

//-----------------------------------------------------------------------------------

	/**
	 * purpose-binarySearch
	 * @param a-array
	 * @param search-element to search
	 * @return
	 */
	public static int binarySearchInteger(int [] a,int search)
	{
		int l=0,h=a.length-1;
		while(l<=h)
		{
			int mid=(l+h)/2;
			if(a[mid]==search)
			{
				return 0;
			}
			else if(a[mid]<search)
			{
				l=mid+1;	
			}
			else {
				h=mid-1;
			}
		}
		return 1;
	}

//---
/**
 * @purpose-Bubble sort.
 * @param a-array.
 * @return-sorted array.
 */
public static int[] bubbleSortInteger(int[] a)
{
	int temp;
	for(int i=0;i<a.length-1;i++)
	{
		for(int j=0;j<a.length-i-1;j++)
		{
			if(a[j]>a[j+1])
			{
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;
			}
		}
	}
	return a;
}


/**
 * purpose 
 * @param a
 * @return
 */
public static String[] bubbleSortString(String[] a)
{
	
	int i,j;
	String temp;
	for(i=0;i<a.length;i++)
	{
		for(j=i+1;j<a.length; j++) 
		{
			if(a[i].compareTo(a[j])<0)
			{
				temp=a[i];
				a[i]=a[j];
				a[j]=temp;
			}
		}
	}
	return a;
}


//-----------------------------------------------------------------------------------


public static void mergeSort(int[] a,int lo,int hi)
{
	if(lo<hi)
	{
		int m= (lo+hi)/2;
		mergeSort(a,lo,m);
		mergeSort(a,m+1 ,hi);
		merge(a,lo,m,hi);
	}
}
public static void merge(int[]a,int lo,int m,int hi)
{
	int a1=m-lo+1;
	int a2=hi-m;
	int x[] =new int[a1];
	int y[]=new int[a2];
	for(int i=0;i<a1;i++)
	{
		x[i]=a[lo+i];
	}
	for(int j=0;j<a2;j++)
	{
		y[j]=a[m+1+j];
	}
	int i=0,j=0,k=lo;
	while(i<a1 && j<a2)
	{
		if(x[i]<=y[j])
		{
			a[k]=x[i];
			i++;
		}else
		{
			a[k]=y[j];
			j++;
		}
		k++;
	}
	while(i<a1)
	{
		a[k]= x[i];
		i++;
		k++;
	}
	while(j<a2)
	{
		a[k]=y[j];
		j++;
		k++;
	}
	
}
/**
 * purpose-prime number checks
 * @param n-number
 * @return
 */
public static boolean primeCheck(int n)
{
	boolean check=true;
	if(n<2)
	{
		check=false;
	}
	else
	{
		int i=2;
		while(i<=Math.sqrt(n))
		{
			if(n%i==0)
			{
				check=false;
				break;
			}
			i++;
		}
	}
	return check;
}


//-----------------------------------------------------------------------------------


/**
 * purpose-anagram check
 * @param str1
 * @param str2
 * @return
 */
public static boolean anagram(String str1,String str2)
{
	  if (str1.length() != str2.length())  
	    {  
	        return false;  
	    }   
	    int value = 0;  
	    for (int i = 0; i < str1.length(); i++)  
	    {  
	        value = value ^ (int) str1.charAt(i);  
	        value = value ^ (int) str2.charAt(i);  
	    }  
	    return value == 0;  	
}


//-----------------------------------------------------------------------------------


/**
 * purpose-generate 1-1000 between prime number
 * @param n
 * @return
 */
public static int[] primeSeries(int n)
{
	int i,j,k;
	int []a=new int[168];
	int m=0;
	for(i=1;i<=n;i++)
	{
		k=0;
		for(j=i;j>=1;j--)
		{
			if(i%j==0)
			{
				k++;
			}
		}
		if(k==2)
		{
			a[m]=i;
			m++;
		}
	}
	return a;
}



//-----------------------------------------------------------------------------------

/**
 * purpose-find the anagram from prime numbers range 1-1000
 * @param a
 * @return
 */
public static String[] primeAnagram(int[] a)
{
	int i,j,k=0;
	String s[]=new String[168];
	for(i=0;i<a.length;i++)
	{
		for(j=i+1;j<a.length;j++)
		{
			String str1=Integer.toString(a[i]);
			String str2=Integer.toString(a[j]);
			char[] s1=str1.toCharArray();
			char[] s2=str2.toCharArray();
			Arrays.sort(s1);
			Arrays.sort(s2);
			String x =new String(s1);
			String y=new String(s2);
			 
			if(x.compareTo(y)==0)
			{
				 s[k]= a[i]+"  anagram   "+a[j];
				 k++;
			}
			
		}
	
	}
return s;
}


//------------------------------------------------------------------------------

/**
 * @param a
 * @return
 */
public static String[] primePalindrome(int a[])
{
	String str[]=new String[168];
	int i,temp,sum=0;
	int k=0;
	for(i=0;i<a.length;i++)
	{
	int check=a[i];
	sum=0;
	while(check>0)
	{
		temp=check%10;
		sum=sum*10+temp;
		check=check/10;
		}
	if(a[i]==sum)
		{
		str[k++]=a[i]+ "  palindrome ";
		}
	}
 return str;
}


public static boolean isString(String str)
{
	return ((!str.equals("")) && (str!=null) && (str.matches("^[a-zA-Z ]*$")));
} 

public static boolean isMobileNumber(String str)
{
	return (str.matches("\\d{10}"));
}

public static String replaceString(Matcher mat,String str)
{
	String str1="";
	while(mat.find())
	{
		str1=mat.replaceFirst(str);
	}
	return str1;
}

}
